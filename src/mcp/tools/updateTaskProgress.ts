import path from "node:path";

import {
    taskUpdateInputSchema,
    taskUpdateResultSchema,
    type TaskUpdateInput,
} from "../schemas/taskUpdate.js";
import {
    enhancedPlanSchema,
    type EnhancedPlan,
    type EnhancedPlanTask,
} from "../schemas/promptEnhancement.js";
import { progressSummarySchema } from "../schemas/orchestration.js";
import type { McpToolDefinition } from "../types.js";
import {
    buildTaskStates,
    computeTotals,
    ensureManifestEntry,
    loadStateManifest,
    resolveStatePath,
    sanitizeTaskStatus,
    updateStateManifest,
} from "../utils/sessionState.js";
import { readJsonSafely, writeFileSafely, writeJsonSafely } from "../../core/utils/fs.js";
import { buildMarkdown } from "./enhancePrompts.js";

const clampPercent = (value: number | undefined, fallback: number): number => {
    const baseline = Number.isFinite(fallback) ? fallback : 0;
    if (value === undefined || Number.isNaN(value)) return baseline;
    if (value < 0) return 0;
    if (value > 100) return 100;
    return Math.round(value * 10) / 10;
};

const DEFAULT_NOTE_PREFIX = "Progress update";

const appendNote = (existingNotes: unknown, message: string): string[] => {
    const list = Array.isArray(existingNotes) ? existingNotes.map(String) : [];
    list.push(message);
    return list;
};

const findTask = (tasks: EnhancedPlanTask[], taskId: string): EnhancedPlanTask | undefined =>
    tasks.find((task) => task.id === taskId);

const updateTaskList = (
    tasks: EnhancedPlanTask[],
    input: TaskUpdateInput,
): { updatedTasks: EnhancedPlanTask[]; updatedTask: EnhancedPlanTask } => {
    let target: EnhancedPlanTask | undefined;

    const updatedTasks = tasks.map((task) => {
        if (task.id !== input.taskId) {
            return task;
        }

        const previousStatus = sanitizeTaskStatus(task.status ?? "pending");
        const previousProgress = task.progressPercent ?? 0;
        const requestedStatus = sanitizeTaskStatus(input.status ?? previousStatus);

        let derivedProgress: number | undefined = input.progressPercent;

        if (derivedProgress === undefined) {
            if (requestedStatus === "done") {
                derivedProgress = 100;
            } else if (requestedStatus === "pending") {
                derivedProgress = 0;
            } else if (requestedStatus === "in_progress") {
                derivedProgress = Math.max(previousProgress, 50);
            }
        }

        const nextProgress = clampPercent(derivedProgress, previousProgress);

        target = {
            ...task,
            status: requestedStatus,
            progressPercent: nextProgress,
        };

        return target;
    });

    if (!target) {
        throw new Error(`Task ${input.taskId} not found in session ${input.sessionId}.`);
    }

    return { updatedTasks, updatedTask: target };
};

export const createTaskProgressUpdateTool = (): McpToolDefinition => ({
    name: "updateTaskProgress",
    description:
        "Update the status and/or completion percent of a TODO task generated by Orka, refreshing state artifacts.",
    parameters: taskUpdateInputSchema,
    execute: async (rawArgs) => {
        const args = taskUpdateInputSchema.parse(rawArgs);
        const baseDirectory = path.isAbsolute(args.outputDirectory)
            ? args.outputDirectory
            : path.resolve(process.cwd(), args.outputDirectory);
        const statePath = resolveStatePath(baseDirectory);
        const manifest = await loadStateManifest(statePath);
        const sessionEntry = ensureManifestEntry(manifest, args.sessionId);

        const planRaw = await readJsonSafely<unknown>(sessionEntry.files.plan);
        if (!planRaw) {
            throw new Error(`Plan file missing for session ${args.sessionId}.`);
        }
        const plan = enhancedPlanSchema.parse(planRaw);

        const { updatedTasks, updatedTask } = updateTaskList(plan.tasks, args);

        const progressRaw = await readJsonSafely<any>(sessionEntry.files.progress);
        const manifestRaw = await readJsonSafely<any>(sessionEntry.files.manifest);
        const projectContext = manifestRaw?.projectContext;

        const updatedPlan: EnhancedPlan = {
            ...plan,
            tasks: updatedTasks,
        };

        const markdown = buildMarkdown(updatedTasks, projectContext);
        updatedPlan.markdown = markdown;

        await writeJsonSafely(sessionEntry.files.plan, updatedPlan);
        await writeFileSafely(sessionEntry.files.markdown, markdown);

        const taskStates = buildTaskStates(
            updatedTasks.map((task) => ({
                id: task.id,
                title: task.title,
                status: task.status,
                progressPercent: task.progressPercent,
            })),
        );
        const totals = computeTotals(taskStates);

        const timestamp = new Date().toISOString();
        const progressPayload = {
            ...(progressRaw ?? {}),
            updatedAt: timestamp,
            totals,
            tasks: taskStates,
        };
        progressSummarySchema.parse({
            sessionId: args.sessionId,
            totals,
            tasks: taskStates,
        });
        await writeJsonSafely(sessionEntry.files.progress, progressPayload);

        const noteMessage = args.note ? `${timestamp}: ${args.note}` : undefined;
        const manifestPayload = {
            ...(manifestRaw ?? {}),
            updatedAt: timestamp,
            totals,
            tasks: taskStates,
        };
        if (noteMessage) {
            manifestPayload.notes = appendNote(manifestPayload.notes, noteMessage);
        }
        await writeJsonSafely(sessionEntry.files.manifest, manifestPayload);

        await updateStateManifest(statePath, {
            sessionId: sessionEntry.sessionId,
            prompt: sessionEntry.prompt,
            createdAt: sessionEntry.createdAt,
            updatedAt: timestamp,
            totals,
            tasks: taskStates,
            files: {
                ...sessionEntry.files,
                markdown: sessionEntry.files.markdown,
                plan: sessionEntry.files.plan,
                analysis: sessionEntry.files.analysis,
                progress: sessionEntry.files.progress,
                manifest: sessionEntry.files.manifest,
                state: statePath,
            },
        });

        const response = taskUpdateResultSchema.parse({
            sessionId: args.sessionId,
            taskId: args.taskId,
            status: updatedTask.status,
            progressPercent: updatedTask.progressPercent,
            totals,
            files: {
                plan: sessionEntry.files.plan,
                progress: sessionEntry.files.progress,
                markdown: sessionEntry.files.markdown,
                manifest: sessionEntry.files.manifest,
                state: statePath,
            },
        });

        return JSON.stringify(response, null, 2);
    },
});
